





互联网工程任务组（IETF）                  R. Fielding编。
征求意见稿：7230奥多比
废弃：2145, 2616                                    J. Reschke编。
更新：2817, 2818                                          绿色字节
类别：标准跟踪                                      2014年6月
ISSN：2070-1721


超文本传输协议（HTTP/1.1）：消息语法与路由

摘要

超文本传输协议（HTTP）是一种无状态的应用层协议
分布式、协作式超文本信息层次协议
系统。本文档概述了HTTP架构，并
其相关术语定义了“http”和“https”统一
资源标识符（URI）方案，定义了HTTP/1.1消息
语法和解析要求，并描述了相关的安全性
对实现的担忧。

本备忘录的状态

这是一份互联网标准跟踪文档。

本文档是互联网工程任务组的成果
（IETF）。它代表了IETF社区的共识。它有
已收到公众评审，并已获得出版批准
互联网工程指导小组（IESG）。更多信息请见
互联网标准见RFC 5741的第2节。

关于本文档当前状态的信息，以及任何勘误表，
关于如何提供反馈的信息，可以在以下地址获取：
http://www.rfc-editor.org/info/rfc7230。


















Fielding & Reschke 标准跟踪 [第1页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


版权声明

版权所有 (c) 2014 IETF 信托及被认定为
文档作者。保留所有权利。

本文档受BCP 78和IETF信托法律条款的约束
与IETF文档相关的规定
（http://trustee.ietf.org/license-info）自生效之日起
本文件的发布。请查阅这些文件
请仔细阅读，因为它们描述了您在相关方面的权利和限制
到此文档。从此文档中提取的代码组件必须
包含如第4.e节所述的简化BSD许可证文本
信任法律条款，且在无担保的情况下提供
如简化BSD许可证所述。

本文档可能包含来自IETF文档或IETF的材料
在11月之前发布或公开的贡献
10, 2008.  控制本文件部分版权的人员
材料可能并未授予IETF（互联网工程任务组）信任机构授权允许的权力
在IETF标准流程之外对此类材料所做的修改。
未从控制者处获得适当许可
这些材料的版权，本文件不得修改
在IETF标准流程之外，其衍生作品可能
不得在IETF标准流程之外创建，除非是为了格式化
将其作为RFC发布，或将其翻译成其他语言
比英语更。

目录

1. 引言 ....................................................5
1.1. 要求表示法 ......................................6
1.2. 语法表示法 ............................................6
2. 架构 ....................................................6
2.1. 客户端/服务器消息传递 ....................................7
2.2. 实现多样性 ...................................8
2.3. 中介机构 .............................................9
2.4. 缓存 ....................................................11
2.5. 一致性和错误处理 ............................12
2.6. 协议版本控制 .......................................13
2.7. 统一资源标识符 ..............................16
2.7.1. HTTP URI方案 ....................................17
2.7.2. https URI方案 ...................................18
2.7.3. HTTP和HTTPS URI的规范化与比较....19
3. 消息格式 ..............................................................19
3.1. 起始行 ................................................20
3.1.1. 请求行 .......................................21
3.1.2. 状态行 ........................................22
3.2. 头部字段 .............................................22



Fielding & Reschke 标准跟踪 [第2页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


3.2.1. 字段可扩展性 ................................23
3.2.2. 字段顺序 ........................................23
3.2.3. 空白 .........................................24
3.2.4. 字段解析 ......................................25
3.2.5. 字段限制 .......................................26
3.2.6. 字段值组件 .............................27
3.3. 消息体 ..............................................28
3.3.1. 传输编码 ..................................28
3.3.2. 内容长度 .....................................30
3.3.3. 消息体长度 ................................32
3.4. 处理不完整消息 ..............................34
3.5. 消息解析鲁棒性 ................................34
4. 传输编码 ...............................................35
4.1. 分块传输编码 ...................................36
4.1.1. 分块扩展 ...................................36
4.1.2. 分块预告片部分 ...............................37
4.1.3. 解码分块 ...................................38
4.2. 压缩编码 .......................................38
4.2.1. 压缩编码 ....................................38
4.2.2. Deflate编码 .....................................38
4.2.3. Gzip编码 ........................................39
4.3. TE ........................................................39
4.4. 预告片 ...................................................40
5. 消息路由 ................................................40
5.1. 识别目标资源 .............................40
5.2. 入站连接 ........................................41
5.3. 请求目标 ............................................41
5.3.1. 起源形式 ........................................42
5.3.2. 绝对形式 ......................................42
5.3.3. 权限表单 .....................................43
5.3.4. 星号形式 ......................................43
5.4. 主机 ......................................................44
5.5. 有效请求URI .....................................45
5.6. 将响应与请求相关联 .......................46
5.7. 消息转发 ........................................47
5.7.1. 通过................................................47
5.7.2. 转换 ....................................49
6. 连接管理 ..........................................50
6.1. 连接 ................................................51
6.2. 建立 .............................................52
6.3. 持久性 ...............................................52
6.3.1. 重试请求 ..................................53
6.3.2. 流水线 .........................................54
6.4. 并行性 ...............................................55
6.5. 失败与超时 .....................................55
6.6. 拆除 ..........................................................56
6.7. 升级 ...................................................57
7. ABNF列表扩展：#规则 .....................................59



Fielding & Reschke 标准跟踪 [第3页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


8. IANA（互联网号码分配机构）考虑因素 ............................61
8.1. 头部字段注册 ......................................61
8.2. URI方案注册 ...................................62
8.3. 互联网媒体类型注册 ..........................62
8.3.1. 互联网媒体类型 message/http ...................62
8.3.2. 互联网媒体类型 application/http ...............63
8.4. 传输编码注册表 ..................................64
8.4.1. 程序 ..........................................65
8.4.2. 注册 .......................................65
8.5. 内容编码注册 ...............................66
8.6. 升级令牌注册表 ....................................66
8.6.1. 程序 ..........................................66
8.6.2. 升级令牌注册 .........................67
9. 安全考虑 ........................................67
9.1. 建立权威 ....................................67
9.2. 中介机构的风险 ...................................68
9.3. 通过协议元素长度进行的攻击 .......................69
9.4. 响应拆分 ........................................69
9.5. 请求欺骗 .........................................70
9.6. 消息完整性 .........................................70
9.7. 消息保密性 ...................................71
9.8. 服务器日志信息的隐私 .........................71
10. 致谢 ...............................................................72
11. 参考文献 ....................................................74
11.1. 规范性引用 .....................................74
11.2. 参考性引用 ...................................75
附录A. HTTP版本历史 ..................................78
A.1. 与HTTP/1.0的差异 ....................................78
A.1.1. 多宿主Web服务器 ............................78
A.1.2. 保持活动连接 ............................79
A.1.3. 传输编码介绍 ........................79
A.2. 与RFC 2616的差异 ....................................80
附录B. 收集的ABNF ........................................82
索引 .............................................................85

















Fielding & Reschke 标准跟踪 [第4页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


1. 引言

超文本传输协议（HTTP）是一种无状态的应用层协议
水平使用可扩展语义的请求/响应协议，以及
用于灵活交互的自我描述性消息载荷
基于网络的超文本信息系统。本文档是
这是共同构成HTTP/1.1的一系列文档中的第一份
规范：

1. “消息语法和路由”（本文件）

2. “语义与内容”[RFC7231]

3. “条件请求”[RFC7232]

4. “范围请求” [RFC7233]

5. “缓存”[RFC7234]

6. “认证”[RFC7235]

本HTTP/1.1规范取代了关于HTTP的RFC 2616和RFC 2145
版本控制）。本规范还更新了CONNECT的使用
建立一条隧道，该隧道在RFC 2817中已有定义，并定义了
在RFC 2818中非正式描述的“https”URI方案。

HTTP是信息系统的一种通用接口协议。它是
旨在隐藏服务实现方式的细节
向客户端呈现一个统一的接口，该接口独立于
所提供的资源类型。同样地，服务器无需
了解每个客户端的目的：一个HTTP请求可以被视为
隔离，而不是与特定类型的客户端相关联
或者按照预定的应用步骤顺序进行。其结果为
可在多种不同情境下有效使用的协议
其实现可以随时间独立发展。

HTTP还被设计为一种中介协议，用于
将通信翻译成非HTTP信息系统，以及从非HTTP信息系统翻译通信。
HTTP代理和网关可以提供对替代服务的访问
通过将各种不同的协议转换为一种统一格式，实现信息服务
一种超文本格式，可供客户端查看和操作
与HTTP服务相同的方式。

这种灵活性的一个后果是，该协议无法被
根据接口后发生的情况来定义。相反，我们
仅限于定义通信的语法，其意图是
接收到的通信，以及接收者的预期行为。如果
通信被视为孤立的情况，然后是成功的操作



Fielding & Reschke 标准跟踪 [第5页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


应体现在对可观察量的相应更改中
服务器提供的接口。然而，由于可能有多个客户端
由于各方可能并行行动，甚至存在相互冲突的目标，我们无法要求
此类更改在单个响应范围之外是可观察到的。

本文档描述了所使用的架构元素或
在HTTP标准协议中，定义了“http”和“https”这两种URI方案，
描述了整体网络操作和连接管理，以及
定义了HTTP消息的帧化和转发要求。我们的目标
其目的是定义HTTP消息所需的所有机制
处理方式与消息语义无关，从而定义了
消息解析器的完整需求集和消息-（此处由于原文不完整，无法给出完整翻译，需根据上下文补充完整）
转发中介体。

1.1. 要求符号

关键词“MUST”、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”，
此处的“SHOULD”、“SHOULD NOT”、“RECOMMENDED”、“MAY”和“OPTIONAL”是HTTP标准协议中的术语，分别表示“应”、“不应”、“建议”、“可”和“可选”
文档应按照[RFC2119]中的描述进行解释。

一致性标准和关于错误处理的考虑因素是
在第2.5节中定义。

1.2. 语法表示法

本规范采用增强的巴科斯-诺尔范式（ABNF）
[RFC5234]的符号表示法，带有列表扩展，在第7节中定义，
这允许使用某种方式（此处原文未给出具体方式，需根据上下文补充）来简洁地定义以逗号分隔的列表
'#' 运算符（类似于 '*' 运算符表示重复）。
附录B展示了收集到的包含所有列表运算符的语法
扩展为标准ABNF（抽象巴科斯范式）表示法。

以下核心规则通过引用包含在内，如以下文档中所定义
[RFC5234]，附录B.1：ALPHA（字母）、CR（回车符）、CRLF
(CR LF)，CTL（控制符），DIGIT（数字0-9），DQUOTE（双引号），
HEXDIG（十六进制0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行符）
feed）、OCTET（任何8位数据序列）、SP（空格）和VCHAR（任何
可见字符（USASCII编码）。

按照惯例，以“obs-”为前缀的ABNF规则名称表示
由于历史原因而出现的“过时”语法规则。

2. 架构

HTTP是为万维网（WWW）架构而创建的，并且具有
随着时间的推移，它不断发展以支持全球范围内的可扩展性需求
超文本系统。该架构的许多方面都体现在
用于定义HTTP的术语和语法规则。



Fielding & Reschke 标准跟踪 [第6页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


2.1. 客户端/服务器消息传递

HTTP是一种无状态的请求/响应协议，其工作方式为
通过可靠传输交换消息（第3节）或
会话层“连接”（第6节）。HTTP“客户端”是一个
用于建立与服务器连接的程序，其目的是
发送一个或多个HTTP请求。HTTP“服务器”是一个程序
该实体接受连接，以便通过发送来处理HTTP请求
HTTP响应。

“客户端”和“服务器”这两个术语仅指代这些
程序为特定连接执行操作。同一个程序可能
在某些连接上充当客户端，在另一些连接上充当服务器。术语
“user agent”指的是各种客户端程序中的任何一种
发起请求，包括（但不限于）浏览器、爬虫
（基于网络的机器人）、命令行工具、自定义应用程序，以及
移动应用。“源服务器”一词指的是能够
为给定的目标资源发起权威响应。这
术语“发送方”和“接收方”指的是任何发送数据的实现
或者分别接收到给定的消息。

HTTP依赖于统一资源标识符（Uniform Resource Identifier，URI）标准
[RFC3986] 用于指示目标资源（第5.1节）
资源之间的关系。消息以某种格式传递
类似于互联网邮件[RFC5322]和多功能邮件扩展（MMS）所使用的格式
互联网邮件扩展（MIME）[RFC2045]（见附录A）
[RFC7231] 用于解释HTTP和MIME消息之间的差异。

大多数HTTP通信都包含一个检索请求（GET）
由URI标识的某种资源的表示。在最简单的情况下
在这种情况下，这可以通过一个单一的双向通信来实现
用户代理（UA）与源（origin）之间的连接（===）
服务器（O）。

请求 >
UA ======================================= O
<   response

客户端以请求的形式向服务器发送一个HTTP请求
消息，以一个请求行开头，该请求行包含一个方法、URI，
以及协议版本（第3.1.1节），后跟头部字段
包含请求修饰符、客户端信息和表示形式
元数据（第3.2节），用空行表示该部分的结束
头部（header）部分，最后是包含有效载荷（payload）的消息体（message body）
正文（如果有，见第3.3节）。






Fielding & Reschke 标准跟踪 [第7页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


服务器通过发送一个或多个HTTP响应来回应客户端的请求
响应消息，每条消息都以一个状态行开头，该状态行包含
协议版本、成功或错误代码以及文本原因
短语（第3.1.2节），后面可能跟着包含头字段的
服务器信息、资源元数据和表示元数据
（第3.2节），用空行表示报头结束
一个部分，最后是一个包含有效载荷主体的消息体（如果存在）
（见HTTP标准协议，第3.3节）。

一个连接可能用于多次请求/响应交换，
如第6.3节所定义。

以下示例说明了一个典型的消息交换过程
对URI的GET请求（[RFC7231]的第4.3.1节）
"http://www.example.com/hello.txt"：

客户端请求：

GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi


服务器响应：

HTTP/1.1 200 OK
日期：2009年7月27日星期一 12:28:53 GMT
服务器：Apache
Last-Modified: 2009年7月22日星期三 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges：字节
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

你好世界！我的载荷包含一个尾随的CRLF（回车换行符）。

2.2. 实现多样性

在考虑HTTP的设计时，很容易陷入一个陷阱
认为所有用户代理都是通用浏览器，并且所有
源服务器是大型公共网站。但情况并非如此
实践。常见的HTTP用户代理包括家用电器，
立体声系统、音阶、固件更新脚本、命令行程序，
移动应用，以及多种形态和功能的通信设备
尺寸。同样，常见的HTTP源服务器包括家庭自动化设备




Fielding & Reschke 标准跟踪 [第8页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


单元、可配置网络组件、办公设备，
自主机器人、新闻推送、交通摄像头、广告选择器，以及
视频传输平台。

“用户代理”一词并不意味着存在人类用户
在某个时间点直接与软件代理进行交互
请求。在许多情况下，用户代理被安装或配置为
在后台运行，并保存其结果以供日后检查（或
仅保存那些可能有趣或重要的结果中的一部分
（例如，蜘蛛程序通常会被赋予一个起始URI）
并配置为在爬取网络时遵循特定行为
超文本图。

HTTP的实现多样性意味着并非所有用户代理
可以向用户提出交互式建议或提供足够的
出于安全或隐私考虑的警告。在少数情况下
本规范要求向用户报告错误，即
对于此类报告而言，只有在出现错误时才可观察到
控制台或日志文件。同样，对于自动化操作的要求
在继续之前，可能需要用户进行确认，这可以通过预先的方式来实现
配置选择、运行时选项，或简单避免
不安全操作；确认并不意味着任何特定用户
如果用户有，则中断或干扰正常处理
已经做出了那个选择。

2.3. 中介机构

HTTP允许使用中介来满足请求
连接链。HTTP有三种常见形式
中介：代理、网关和隧道。在某些情况下，单个
中间设备可能充当源服务器、代理、网关或
隧道，根据每个请求的性质进行切换行为。

>             >             >             >
UA =========== A =========== B =========== C =========== O
<             <             <             <

上图展示了三个中介（A、B和C）
用户代理和源服务器。一条请求或响应消息
在整个链的传输过程中，将经过四个独立的连接。
某些HTTP通信选项可能仅适用于连接
与最近的非隧道邻居通信，仅限于端点之间
链，或链上的所有连接。尽管图中
是线性的，每个参与者可能参与多个，
同时通信。例如，B可能正在接收
来自除A外的多个客户端的请求，和/或转发请求
在处理A事务的同时，向除C以外的服务器发送




Fielding & Reschke 标准跟踪 [第9页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


请求。同样地，后续的请求可能会通过不同的方式发送
连接路径，通常基于负载的动态配置
平衡。

术语“上游”和“下游”用于描述
与消息流相关的方向性要求：全部
消息从上游流向下游。“入站”和
“outbound”用于描述与方向相关的要求
对于请求路由：“inbound”表示朝向源服务器
“outbound”指的是朝向用户代理的方向。

“代理”是一种消息转发代理，由...选择
客户端，通常通过本地配置规则，来接收请求
对于某些类型的绝对URI，并尝试满足这些URI
通过HTTP接口进行翻译请求。一些
翻译是极简的，例如对于“http”URI的代理请求，
而其他请求可能需要完全双向的翻译
不同的应用层协议。代理通常用于
通过一个公共中介将一个组织的HTTP请求进行分组
出于安全、注释服务或共享缓存的考虑。
某些代理被设计为对选定内容进行转换
在转发消息或有效载荷时，如所述
第5.7.2节。

“网关”（亦称“反向代理”）是一个中介，它充当
出站连接的源服务器，但会对接收到的内容进行转换
接收请求并将其转发到另一个或多个服务器。
网关通常用于封装遗留系统或不受信任的系统
信息服务，通过...来提高服务器性能
“加速器”缓存，并启用分区或负载均衡
跨多台机器的HTTP服务。

所有适用于源服务器的HTTP要求同样适用于
网关的出站通信。网关与...进行通信
入站服务器可使用其所需的任何协议，包括私有协议
本规范范围之外的HTTP扩展。
然而，一个希望实现互操作的HTTP到HTTP网关
第三方HTTP服务器应符合用户代理要求
在网关的入站连接上。

“隧道”作为两个连接之间的隐蔽中继，无需
更改消息。一旦激活，隧道就不再被视为
HTTP通信的参与方，尽管隧道可能已经
由HTTP请求发起。当两端都关闭时，隧道即不复存在
中继连接的端点已关闭。隧道被用于
通过中介扩展虚拟连接，例如在以下情况时
传输层安全（TLS，[RFC5246]）用于建立
通过共享防火墙代理进行的机密通信。



Fielding & Reschke 标准跟踪 [第10页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


上述中介类别仅考虑那些作为中介行事的人
HTTP通信中的参与者。此外还有
能够在网络协议较低层上执行操作的中介机构
堆叠、过滤或重定向HTTP流量，而无需通知或
消息发送者的权限。网络中介机构是
（在协议层面）与中间人攻击无法区分
攻击，往往会导致安全漏洞或互操作性问题
由于错误地违反了HTTP语义。

例如，“拦截代理”[RFC3040]（也常被称为
作为“透明代理”[RFC1919]或“强制门户”时，其与...有所不同
一个HTTP代理，因为它没有被客户端选中。相反，一个
拦截代理过滤或重定向传出TCP端口80的数据包
（偶尔也包括其他常见端口流量）。拦截代理
通常在公共网络接入点上可以找到它们，作为...的一种手段
在允许使用非本地内容之前，先强制执行账户订阅
互联网服务，以及在企业防火墙内部执行网络
使用策略。

HTTP被定义为一种无状态协议，这意味着每个请求
消息可以单独理解。许多实现依赖于
关于HTTP的无状态设计，以便重用代理连接或
在多个服务器之间动态地负载均衡请求。因此，一个
服务器不得假设同一连接上的两个请求是
除非连接是安全的，否则来自同一用户代理的请求
特定于该代理。一些非标准的HTTP扩展（例如。，
[RFC4559]）已知违反了这一要求，导致
安全性和互操作性问题。

2.4. 缓存

“缓存”是本地存储的先前响应消息，以及
控制其消息存储、检索和删除的子系统。
缓存存储可缓存的响应，以减少响应次数
时间和网络带宽消耗对未来等效的影响
请求：任何客户端或服务器都可以使用缓存，尽管缓存
在服务器充当隧道时，无法被其使用。

缓存的作用在于缩短请求/响应链
如果链上的某个参与者拥有缓存的响应
适用于该请求。以下是对结果的说明
如果B（通过C）缓存了O之前的一个响应，则将该响应加入链中
对于未被UA或A缓存的请求。

>             >
UA =========== A =========== B - - - - - - C - - - - - - O
<             <




Fielding & Reschke 标准跟踪 [第11页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


如果一个缓存被允许存储一份响应的副本，那么这个响应就是“可缓存的”
用于回答后续请求的响应消息。甚至
当响应可缓存时，可能存在额外的约束条件
当缓存时，由客户端或源服务器设置
响应可用于特定的请求。HTTP要求
缓存行为和可缓存响应的定义见第2节
[RFC7234]。

缓存的架构和配置多种多样
部署于万维网及大型组织内部。
这些包括用于保存的代理缓存的国家层级结构
跨洋带宽，用于广播或协作的系统
多播缓存条目，即预取缓存条目的存档
用于离线或高延迟环境等。

2.5. 一致性与错误处理

本规范针对的是根据角色设定的合规性标准
HTTP通信中的参与者。因此，HTTP要求是
放置在发送者、接收者、客户端、服务器、用户代理上，
中介、源服务器、代理、网关或缓存，
这取决于需求所约束的行为是什么。
对实现提出了额外的（社会）要求，
资源所有者，以及协议元素注册（在适用时）
超出了单次通信的范围。

在需求中，使用动词“生成”而不是“发送”
区分创建协议元素与仅仅
将接收到的元素转发到下游。

如果实现符合所有...，则认为该实现是符合标准的
与它在HTTP中所扮演的角色相关的要求。

一致性包括协议的语法和语义
元素。发送方不得生成传达以下信息的协议元素：
即发送方已知该信息为虚假。发送方严禁
生成不符合所定义语法的协议元素
相应的ABNF规则。在给定的消息中，发送者必须
不生成仅具有特定功能的协议元素或语法选项
允许由其他角色的参与者生成（即，一个角色
即发送者对该消息不具有（某种权利或能力）。

当解析收到的协议元素时，接收方必须
能够解析任何合理长度的适用值
接收方的角色，并且该角色符合由...定义的语法规则
相应的ABNF规则。但请注意，某些收到的协议
元素可能不会被解析。例如，在中间环节




Fielding & Reschke 标准跟踪 [第12页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


转发消息时，可能会将一个头字段解析为通用类型
字段名和字段值组件，但随后转发该头部
字段，不对字段值内部进行进一步解析。

HTTP对其许多部分没有特定的长度限制
协议元素，因为可能合适的长度将
根据部署环境和目的的不同，差异很大
实现。因此，发送方之间的互操作性
接收者依赖于对“什么是”的共同预期
每个协议元素的合理长度。此外，什么是
通常被理解为某些协议的合理长度
在HTTP过去二十年的发展过程中，其元素已经发生了变化
使用中，并预计未来会继续发生变化。

至少，接收方必须能够解析和处理协议
元素长度至少与其值一样长
为其他消息中的相同协议元素生成。对于
例如，一个发布非常长的URI引用的源服务器
其自身的资源需要能够解析和处理这些相同的（内容/数据）
当作为请求目标接收时，会引用。

接收方必须根据以下内容来解释收到的协议元素
本规范为其定义的语义，包括
除非接收方已确定，否则不得对本规范进行扩展
（通过经验或配置）发现发送者存在错误
实现这些语义所暗示的内容。例如，一个
源服务器可能会忽略接收到的内容
如果检查了User-Agent头字段，则检查Accept-Encoding头字段
字段表示已知的特定实现版本
在接收到某些内容编码时失败。

除非另有说明，否则接收方可以尝试恢复可用数据
来自无效构造的协议元素。HTTP未定义
特定的错误处理机制，除非它们有直接的关联
对安全性的影响，因为协议的不同应用
需要不同的错误处理策略。例如，一个Web
浏览器可能希望从响应中透明地恢复，其中
位置头字段未按照ABNF（抽象巴科斯范式）进行解析，而a
系统控制客户端可能会考虑任何形式的错误恢复
很危险。

2.6. 协议版本控制

HTTP采用“<major>.<minor>”的编号方案来表示版本
本协议的版本。本规范定义了版本“1.1”。这
协议版本整体表明发送方符合
该版本对应的文档中列出的一系列要求
HTTP规范。



Fielding & Reschke 标准跟踪 [第13页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


HTTP消息的版本由HTTP版本字段指示
在消息的第一行。HTTP版本是区分大小写的。

HTTP版本 = HTTP名称 / 数字.数字
HTTP-name = %x48.54.54.50; "HTTP"，区分大小写

HTTP版本号由两个十进制数字组成，中间用“.”分隔
"."（句点或小数点）。第一个数字（“主版本号”）
表示HTTP消息语法，而第二位数字（“minor”）
“version”）表示该主要版本中的最高次要版本
发送方符合并能够理解的版本
未来通信。次版本号用于标识发送方的
即使发送方仅使用...（此处需根据上下文补充具体设备或工具），也能保持通信能力
协议的后向兼容子集，从而使得
接收方知道在响应中可以使用更高级的功能
（由服务器）或在未来的请求中（由客户端）。

当一条HTTP/1.1消息被发送给一个HTTP/1.0接收方时[RFC1945]
或者接收方的版本未知，则HTTP/1.1消息是
构造为使其可被解释为有效的HTTP/1.0协议
如果忽略所有较新的特性，则显示消息。本规范
对某些新功能提出了接收者版本要求，以便
符合标准的发送方将仅使用兼容特性，直至其具备
通过配置或接收消息确定
接收方支持HTTP/1.1协议。

在HTTP标准协议中，头字段的解释在版本之间不会发生变化
同一主要HTTP版本的多个版本，尽管默认行为
在没有此类字段的情况下，收件人的信息可能会发生变化。除非
除非另有说明，否则在HTTP/1.1中定义的头字段均保持原定义
适用于所有HTTP/1.x版本。特别是Host和Connection部分
头部字段应由所有HTTP/1.x实现实现
无论它们是否声明符合HTTP/1.1标准。

可以在不改变协议的情况下引入新的头字段
版本（version），如果其定义的语义允许它们被安全地忽略
无法识别它们的接收者。头部字段的可扩展性是
在第3.2.1节中进行了讨论。

处理HTTP消息的中介（即，所有中介）
除了充当隧道的其他实体）必须发送它们自己的HTTP版本信息
在转发消息中。换言之，它们是不被允许的
盲目转发HTTP消息的第一行，而不进行任何确保
该消息中的协议版本与某个版本相匹配
该中介体符合接收和发送的HTTP标准协议
消息。在不重写的情况下转发HTTP消息





Fielding & Reschke 标准跟踪 [第14页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


当下游处理时，HTTP版本可能会引发通信错误
接收者使用消息发送者的版本信息来确定具体内容
这些特性可以安全地用于后续与该发送方的通信。

客户端应发送一个请求版本，该版本应等于最高版本
客户端符合该协议，且其主版本号不大于
如果高于服务器支持的最高版本，则
已知。客户端不得发送其不支持的版本
符合的。

如果客户端知道，它可能会发送一个较低的请求版本
服务器错误地实现了HTTP规范，但只是在……之后
客户端已尝试至少一个正常请求，并已确定
从响应状态码或头字段（例如，Server）中
服务器对更高版本的请求处理不当。

服务器应当发送一个版本号等于最高版本的响应
服务器符合的协议，其主版本号小于
或等于请求中接收到的值。服务器不得发送
一个它不符合的版本。服务器可以发送一个505
（HTTP版本不支持）响应，无论出于何种原因，
拒绝客户端主要协议版本的服务。

如果已知或
怀疑客户端错误地实现了HTTP协议
规范，并且无法正确处理后续版本
响应，例如当客户端无法解析版本号时
在正确的情况下，或者当已知中间人会盲目转发时
即使HTTP版本不符合给定的次要版本
协议的。此类协议降级操作不应当执行
除非由特定的客户端属性触发，例如当一个或多个客户端属性满足特定条件时
更多的请求头字段（例如，User-Agent）唯一匹配
客户端发送的值已知有误。

HTTP版本号设计的意图在于，主要版本号
仅当存在不兼容的消息语法时，才会进行递增
引入了，并且次要编号仅在以下情况下才会递增：
对协议所做的更改具有增加消息内容的效果
语义或暗示发送方的额外能力。
然而，这些变更并未导致次版本号增加
在[RFC2068]和[RFC2616]之间引入，并且此次修订具有
特别避免对协议进行任何此类更改。

当收到的主要版本号与预期不符的HTTP消息时
接收方实现，但其次版本号高于
接收方实现，接收方应按照以下方式处理消息：
它处于该主要版本中的最高次要版本
接收方是符合要求的。接收方可以假设



Fielding & Reschke 标准跟踪 [第15页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


当发送给一个接收者时，带有更高次版本号的消息
尚未表示支持该更高版本，是
具有足够的向后兼容性，能够被任何（系统/程序）安全处理
相同主版本的实现。

2.7. 统一资源标识符

统一资源标识符（URIs）[RFC3986]在整个过程中被使用
HTTP作为标识资源的手段（见[RFC7231]第2节）。
URI引用用于定位请求、指示重定向，以及
定义关系。

“URI引用”、“绝对URI”、“相对部分”的定义，
“scheme”、“authority”、“port”、“host”、“path-abempty”、“segment”，
“query”和“fragment”是从URI通用语法中采纳的。一
“absolute-path”规则是为那些可以定义的协议元素而设定的
包含一个非空路径组件。（此规则与……略有不同）
RFC 3986中的path-abempty规则，该规则允许空路径
在引用中使用，以及路径绝对规则，该规则不允许
以“//”开头的路径。）定义了一个“部分URI”规则
可以包含相对URI但不能包含片段的协议元素
组件。

URI引用 = <URI引用，参见[RFC3986]，第4.1节>
absolute-URI = <绝对URI，参见[RFC3986]，第4.3节>
相对部分 = <相对部分，参见[RFC3986]，第4.2节>
scheme = <scheme，参见[RFC3986]，第3.1节>
authority = <authority，参见[RFC3986]，第3.2节>
uri-host = <主机，参见[RFC3986]，第3.2.2节>
端口 = <端口，参见[RFC3986]，第3.2.3节>
path-abempty = <path-abempty，参见[RFC3986]，第3.3节>
segment = <段，参见[RFC3986]，第3.3节>
query = <查询，参见[RFC3986]，第3.4节>
fragment = <片段，参见[RFC3986]，第3.5节>

绝对路径 = 1*( "/" 片段 )
partial-URI = relative-part [ "?" query ]

HTTP中每个允许URI引用的协议元素都将
在其ABNF（抽象巴科斯范式）产生式中表明该元素是否允许任何形式
引用（URI引用），仅指绝对形式的URI
（绝对URI），仅包含路径和可选查询组件，或部分
上述各项的组合。除非另有说明，否则URI引用
根据有效请求URI（第5.5节）进行解析。







Fielding & Reschke 标准跟踪 [第16页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


2.7.1. HTTP URI方案

“http”URI方案特此定义，用于铸造（或生成、创建）
根据其与层级结构的关联性来标识符
由潜在的HTTP源服务器管理的命名空间倾听
给定端口上的TCP（[RFC0793]）连接。

http-URI = "http:" "//" 权威路径-绝对路径 [ "?" 查询参数 ]
[ "#" 片段 ]

“http”URI的源服务器由授权机构标识
组件，包括主机标识符和可选的TCP端口
（[RFC3986]，第3.2.2节）。层级路径组件和
可选查询组件作为潜在项的标识符
该源服务器名称空间内的目标资源。可选
片段组件允许间接识别次级组件
资源，独立于URI方案，如第3.5节所定义
[RFC3986]。

发送方不得生成主机为空的“http”URI
标识符。处理此类URI引用的接收方必须
将其视为无效并拒绝。

如果主机标识符是以IP地址的形式提供的，则源站
服务器是位于该IP地址的指定TCP端口上的监听器（如果有的话）
地址。如果主机是一个注册名称，则该注册名称是
用于名称解析服务的间接标识符，例如
DNS，用于查找该源服务器的地址。如果端口
子组件为空或未指定，TCP端口80（保留端口）
对于WWW服务，默认设置是（未给出具体内容，根据上下文推测可能为“使用WWW服务时”）。

请注意，存在具有给定授权组件的URI
并不意味着总有一个HTTP服务器在监听
该主机和端口上的连接。任何人都可以生成一个URI。（注：URI，即统一资源标识符，是互联网上唯一标识资源的字符串，通常用于网络服务的定位和寻址。在此上下文中，它可能指的是一个特定的网络服务或资源。）。什么
权限组件确定谁有权进行响应
对针对已标识资源的请求进行权威性处理。这
注册名称和IP地址的委托性质创造了一个
联邦命名空间，基于对指定主机的控制
端口，无论是否存在HTTP服务器。参见第9.1节
与建立权威相关的安全考量。

当在需要访问的上下文中使用“http”URI时
对于所指示的资源，客户端可以通过解析来尝试访问
主机向一个IP地址发起请求，建立到该地址的TCP连接
在指定的端口上，发送一个HTTP请求消息
（第3节）包含用于标识数据（第5节）的URI
服务器。如果服务器对该请求的响应不是临时的




Fielding & Reschke 标准跟踪 [第17页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


如[RFC7231]第6节所述的HTTP响应消息，然后
该响应被视为对客户端的权威性回答
请求。

虽然HTTP独立于传输协议，但“http”
该方案特定于基于TCP的服务，因为名称委托
该过程依赖于TCP来建立权限。一个HTTP服务
基于某种其他底层连接协议，可能会
可以使用不同的URI方案进行标识，就像“https”一样
scheme（如下）用于需要端到端通信的资源
安全连接。其他协议也可能被用来提供
对“http”标识资源的访问——它只是权威性的
特定于TCP的接口。

权威的URI通用语法还包括一个已弃用的
userinfo 子组件（[RFC3986]，第3.2.1节），用于包含用户信息
URI中的认证信息。一些实现会利用
userinfo组件的内部配置
认证信息，例如在命令调用中的认证信息
选项、配置文件或书签列表，即使这些
使用该协议可能会暴露用户标识符或密码。发送方严禁
当某个条件满足时，生成userinfo子组件（及其“@”分隔符）
在消息中生成“http”URI引用作为请求
目标或头字段值。在使用“http”URI之前
如果从不受信任的来源收到引用，接收方应进行解析
对于userinfo，将其存在视为错误；这很可能是
用于在网络钓鱼攻击中隐藏真实身份或权限。

2.7.2. https URI方案

“https”URI方案特此定义，用于铸币
根据与层次结构的关联性来标识符
由潜在的HTTP源服务器监听的命名空间
为TLS安全连接指定的TCP端口（[RFC5246]）。

上面列出的所有针对“http”方案的要求也
“https”方案的要求，除了TCP端口443是
如果端口子组件为空或未指定，则默认为用户
代理必须确保其与源服务器的连接是安全的
在发送之前，通过使用端到端的强加密
第一个HTTP请求。

https-URI = "https:" "//" 权威路径-abempty [ "?" 查询参数 ]
[ "#" 片段 ]

请注意，“https”URI方案同时依赖于TLS和TCP
建立权威。通过“https”提供的资源
即使它们（指某些方案）与“http”方案没有共享标识，也



Fielding & Reschke 标准跟踪 [第18页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


资源标识符表示相同的权威机构（即相同的主机）
（它们）监听相同的TCP端口）。它们是不同的命名空间，并且
被视为不同的源服务器。然而，存在一个扩展
对于被定义为适用于整个主机域的HTTP，例如
Cookie协议[RFC6265]，允许由一个服务设置信息
影响与匹配组内其他服务的通信
主机域名。

对“https”标识的权威访问过程
资源在[RFC2818]中进行了定义。

2.7.3. http和https URI的规范化与比较

由于“http”和“https”方案符合URI通用规范
根据HTTP标准协议，此类URI会被规范化并根据其语法进行比较
使用[RFC3986]第6节中定义的算法，并使用默认设置
如上所述，针对每种方案进行了描述。

如果端口等于某个方案的默认端口，则正常
格式是省略端口子组件。当不使用时
作为OPTIONS请求的请求目标，使用绝对形式，即一个空字符串
路径组件等同于绝对路径“/”，因此
常规做法是提供一个“/”路径。方案和主机
不区分大小写，通常以小写形式提供；所有其他
组件是以区分大小写的方式进行比较的。角色其他
与“reserved”集合中的那些相比，它们是等价的
百分号编码的字节：通常的形式是不对其进行编码（见
[RFC3986]的第2.1节和第2.2节。

例如，以下三个统一资源标识符（URI）是等价的：

http://example.com:80/~smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html

3. 消息格式

所有HTTP/1.1消息都由一个起始行后跟一个序列组成
以类似于Internet Message Format的格式表示的八位字节
[RFC5322]：零个或多个头部字段（统称为
“headers”或“header部分”），一个空行表示
头部（header）部分的结尾，以及一个可选的消息体（message body）。

HTTP消息 = 开始行
*( 头部字段 CRLF )
回车换行
[消息体]




Fielding & Reschke 标准跟踪 [第19页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


解析HTTP消息的正常流程是读取
将起始行解析为结构，将每个头字段读取到哈希表中
按字段名解析，直到遇到空行，然后使用解析后的数据
判断是否需要消息体。如果已经存在消息体
如果已指示，则将其作为流读取，直到读取到一定数量的八位字节
等于读取的消息体长度，或者连接已关闭。

接收方必须将HTTP消息解析为一系列八位字节序列
编码是US-ASCII（美国信息交换标准代码）的超集。解析HTTP（超文本传输协议）
消息作为Unicode字符流，不考虑其具体内容
特定的编码方式，由于...（此处需根据上下文补充具体原因，如“特定的编码方式可能使得数据在传输过程中容易被篡改或截取，从而产生安全漏洞”）
字符串处理库处理无效字符的不同方式
包含八位字节LF（%x0A）的多字节字符序列。
基于字符串的解析器只能在协议元素内安全使用
在从消息中提取元素之后，例如在（某个具体上下文或操作中）
消息解析后的一个标头字段-值已经划分了
各个字段。

HTTP消息可以解析为流，以便进行增量处理
或者转发到下游。然而，接收者不能依赖
部分消息的增量交付，因为某些实现
为了网络，将缓冲或延迟消息转发
效率、安全检查或载荷转换。

发送方不得在起始行和...之间发送空格
第一个头部字段。接收方在接收时，如果字段之间存在空格
起始行和第一个头字段必须拒绝该消息
作为无效内容，或直接忽略每个以空格开头的行，无需进一步处理
处理它（即，忽略整行，以及任何
后续行前带有空格，直到形成正确格式
收到头字段或头部分终止）。

请求中存在此类空白可能是为了尝试
诱使服务器忽略该字段或处理下一行
将其视为一个新的请求，其中任何一个都可能导致安全问题
请求链中的其他实现存在的漏洞
对同一消息有不同的解释。同样，存在
响应中的此类空白可能会被某些客户端忽略，或者
使其他人停止解析。

3.1. 起始行

HTTP消息可以是客户端向服务器发出的请求，也可以是
服务器对客户端的响应。从语法上讲，有两种类型
消息仅在起始行上有所不同，该行可以是请求行
（对于请求）或状态行（对于响应），以及在算法中
用于确定消息体长度（第3.3节）。




Fielding & Reschke 标准跟踪 [第20页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


理论上，客户端可以接收请求，而服务器也可以接收请求
响应，通过它们不同的起始行格式进行区分，
但在实践中，服务器被实现为仅预期接收一个请求（a
响应被解释为未知或无效的请求方法）并且
客户端被实现为仅期望响应。

起始行 = 请求行 / 状态行

3.1.1. 请求行

请求行以方法标记开头，后跟一个空格
(SP)，请求目标，另一个单空格(SP)，协议
版本，并以CRLF（Carriage Return Line Feed，换行符）结尾。

请求行 = 方法 SP 请求目标 SP HTTP版本 CRLF

方法令牌（method token）表示要对资源执行的请求方法
目标资源。请求方法是区分大小写的。

method = token

本规范定义的请求方法可以在以下位置找到
[RFC7231]的第4节，以及关于HTTP的信息
方法注册表以及定义新方法的考量因素。

请求目标标识了要应用的目标资源
如第5.3节所定义的请求。

接收方通常会将请求行解析为其组成部分
通过空格分割（见第3.5节），因为这里没有空格
在三个组件中是允许的。不幸的是，一些用户代理
无法正确编码或排除超文本中的空白字符
引用，导致那些不允许的字符被发送进来
请求目标。

无效请求行的接收者应当以以下任一方式回应：
400（错误请求）错误或301（永久移动）重定向，带有
请求目标已正确编码。接收方不应尝试
自动更正后处理请求，而不进行重定向，因为
无效的请求行可能是故意设计的，以绕过
请求链上的安全过滤器。

HTTP并未对（某个对象或消息的）长度设置预定义的限制
请求行，如第2.5节所述。服务器接收到一个
比其实现的任何方法都更长的方法应当返回501响应码
（未实现）状态码。接收到该状态码的服务器





Fielding & Reschke 标准跟踪 [第21页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


如果请求目标（request-target）的长度超过它希望解析的任何URI，则必须做出响应
带有414（URI过长）状态码（参见第6.5.12节）
[RFC7231]）。

在请求行长度上存在各种临时限制
实践。建议所有HTTP发送者和接收者
至少支持请求行长度为8000个八位字节。

3.1.2. 状态行

响应消息的第一行是状态行，由以下部分组成
协议版本，一个空格（SP），状态码，另一个
space，一个可能为空的文本短语，用于描述状态码，
并以CRLF（Carriage Return Line Feed，换行符）结束。

状态行 = HTTP版本 SP 状态码 SP 原因短语 CRLF

状态码元素是一个3位整数代码，用于描述
服务器尝试理解并满足客户端请求的结果
相应的请求。响应消息的其余部分将是
根据为该状态码定义的语义进行解释。
有关语义的信息，请参见[RFC7231]的第6节
状态码，包括状态码的类别（由...指示）
第一个数字），本规范定义的状态码，
新状态码定义的考量因素，以及IANA（互联网号码分配机构）
注册表。

状态码 = 3位数字

reason-phrase元素的唯一存在目的是提供一个
与数字状态码相关的文本描述，主要是
出于对早期互联网应用协议的尊重，这些协议
更常用于交互式文本客户端。客户端应当
忽略原因短语内容。

原因短语 = *( HTAB / SP / VCHAR / 观察文本 )

3.2. 头部字段

每个头字段由一个不区分大小写的字段名后跟
由冒号（“:”）、可选前导空格、字段值和
可选尾部空格。









Fielding & Reschke 标准跟踪 [第22页]

RFC 7230           HTTP/1.1 消息语法和路由         2014年6月


头部字段 = 字段名 ":" 操作状态（OWS） 字段值 操作状态（OWS）

字段名 = 标记
字段值 = *( 字段内容 / 观察折叠 )
字段内容 = 字段-vchar [ 1*( 空格 / 制表符 ) 字段-vchar ]
字段-vchar = VCHAR / obs-text

obs-fold = CRLF 1*( SP / HTAB )
; 过时的行折叠
; 见第3.2.4节

字段名标记将相应的字段值标记为具有
该头部字段定义的语义。例如，Date（日期）
在[RFC7231]的第7.1.1.2节中定义了header字段，该字段包含
该消息出现的原始时间戳。

3.2.1. 字段可扩展性

头部字段是完全可扩展的：对此没有限制
引入新的字段名，每个字段名都假定定义了新的（内容/特性/功能等）
语义，也不取决于给定消息中使用的头字段的数量
消息。本协议的每个部分都定义了现有的字段
规范以及本文件以外的许多其他规范
set。

可以定义新的头部字段，以便在它们被理解时
在接收者看来，它们可能会覆盖或增强对...的解释
对于之前定义的头字段，定义请求的先决条件
评估，或完善响应的含义。

代理必须转发未识别的头部字段，除非字段名
列在Connection头字段（第6.1节）或代理中
被特别配置为阻止或以其他方式转换此类内容
字段。其他接收方应忽略无法识别的头部字段。
这些要求允许HTTP实现其功能